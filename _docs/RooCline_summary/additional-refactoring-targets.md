# 追加リファクタリング対象コンポーネント

このドキュメントでは、BookShelfCard以外のUIコンポーネントについて、リファクタリングの対象となる内容を大まかにまとめています。各コンポーネントごとに、現状の問題点と改善案を提示しています。

## 1. BookCardコンポーネント

### 現状の問題点

- BookShelfCardと同様に、UIと機能の関心が混在している
- カスタムフック（useBookCardState）が多くの状態を管理しており、責務が大きい
- ダイアログコンポーネントがカードコンポーネント内に直接含まれている

### 改善案

1. **UIと機能の分離**

    - UIコンポーネント（`components/book/card/`）と機能コンポーネント（`features/book/components/`）に分離
    - ダイアログの表示ロジックを機能コンポーネントに移動

2. **カスタムフックの分割**

    - `useBookCardState`を複数の小さなフックに分割（例：`useBookDialogs`、`useReadStatus`）
    - 各フックの責務を明確にする

3. **型定義の整理**
    - `types/book.ts`ファイルを作成し、書籍関連の型定義を整理
    - インターフェースを適切に分割

## 2. MemoCardコンポーネント

### 現状の問題点

- コンポーネント内に状態管理とAPIリクエストが直接含まれている
- 複数のダイアログの状態管理が混在している
- 再利用性が低い

### 改善案

1. **UIと機能の分離**

    - UIコンポーネント（`components/memo/card/`）と機能コンポーネント（`features/memo/components/`）に分離
    - APIリクエストをサービス層（`services/memoService.ts`）に抽出

2. **カスタムフックの作成**

    - `useMemoDialogs`フックを作成してダイアログの状態管理を抽出
    - `useMemoMutation`フックを作成してAPIリクエスト関連のロジックを抽出

3. **コンポーネントの分割**
    - `MemoCardHeader`、`MemoCardContent`、`MemoCardActions`などのサブコンポーネントに分割
    - 再利用性を向上させる

## 3. ダイアログコンポーネント

### 現状の問題点

- ダイアログコンポーネント内にAPIリクエストが直接含まれている
- 状態管理が各ダイアログ内で個別に行われている
- 共通のパターンが抽出されていない

### 改善案

1. **UIと機能の分離**

    - UIコンポーネント（`components/dialog/`）と機能コンポーネント（`features/*/dialogs/`）に分離
    - APIリクエストをサービス層に抽出

2. **共通パターンの抽出**

    - `useDialog`フックを作成して共通の状態管理を抽出
    - `DialogForm`などの共通コンポーネントを作成

3. **型定義の整理**
    - ダイアログ関連の型定義を整理
    - 共通のインターフェースを作成

## 4. レイアウトコンポーネント

### 現状の問題点

- レイアウトコンポーネントの責務が不明確
- 再利用性が低い

### 改善案

1. **責務の明確化**

    - レイアウトコンポーネントの責務を明確にする
    - 共通のレイアウトパターンを抽出

2. **コンポーネントの分割**
    - `Header`、`Sidebar`、`Main`、`Footer`などのサブコンポーネントに分割
    - 再利用性を向上させる

## 5. ページコンポーネント

### 現状の問題点

- ページコンポーネント内に状態管理とAPIリクエストが直接含まれている
- UIと機能の関心が混在している
- 共通のパターンが抽出されていない

### 改善案

1. **UIと機能の分離**

    - UIコンポーネント（`components/page/`）と機能コンポーネント（`features/*/pages/`）に分離
    - APIリクエストをサービス層に抽出

2. **カスタムフックの作成**

    - ページごとに必要なカスタムフックを作成
    - 状態管理とAPIリクエストのロジックを抽出

3. **共通パターンの抽出**
    - `PageHeader`、`PageContent`、`PageFooter`などの共通コンポーネントを作成
    - ローディング状態やエラー状態の表示を共通化

## 6. サービス層

### 現状の問題点

- サービス層が不完全で、一部のAPIリクエストがコンポーネント内に直接含まれている
- エラーハンドリングが統一されていない
- 型定義が不十分

### 改善案

1. **サービス層の拡充**

    - 全てのAPIリクエストをサービス層に移動
    - `apiClient.ts`を作成して共通のAxiosインスタンスを提供

2. **エラーハンドリングの統一**

    - 共通のエラーハンドリング関数を作成
    - エラーメッセージの表示方法を統一

3. **型定義の整理**
    - APIレスポンスの型定義を整理
    - サービス関数の戻り値の型を明確にする

## 7. 共通コンポーネント

### 現状の問題点

- 共通コンポーネントの整理が不十分
- 再利用性が低い
- ドキュメントが不足している

### 改善案

1. **共通コンポーネントの整理**

    - `components/ui/`ディレクトリの構造を整理
    - 共通のデザインシステムを確立

2. **再利用性の向上**

    - コンポーネントのプロパティを柔軟に設計
    - バリエーションを提供

3. **ドキュメントの充実**
    - 各コンポーネントにJSDocコメントを追加
    - 使用例を提供

## 8. 型定義

### 現状の問題点

- 型定義が散在している
- インターフェースが大きすぎる
- 型の再利用が不十分

### 改善案

1. **型定義の整理**

    - 機能ごとに型定義ファイルを作成（`types/book.ts`、`types/memo.ts`など）
    - 共通の型を`types/common.ts`に集約

2. **インターフェースの分割**

    - 大きなインターフェースを小さく分割
    - 責務ごとにインターフェースを設計

3. **型の再利用の促進**
    - 共通の型を抽出
    - 型の拡張を活用

## リファクタリングの優先順位

1. **型定義の整理**

    - 他のリファクタリングの基盤となるため、最初に着手

2. **サービス層の拡充**

    - APIリクエストを集約し、コンポーネントからビジネスロジックを分離

3. **BookCardコンポーネント**

    - BookShelfCardと同様のパターンでリファクタリングを行い、一貫性を確保

4. **ダイアログコンポーネント**

    - 多くのコンポーネントで使用されるため、早期にリファクタリングすることで効果が大きい

5. **MemoCardコンポーネント**

    - BookCardと同様のパターンでリファクタリングを行い、一貫性を確保

6. **ページコンポーネント**

    - UIと機能の分離を行い、状態管理を改善

7. **レイアウトコンポーネント**

    - 責務を明確にし、再利用性を向上

8. **共通コンポーネント**
    - デザインシステムを確立し、ドキュメントを充実

## まとめ

BookShelfCard以外のUIコンポーネントについても、同様の原則でリファクタリングを行うことで、コードベース全体の一貫性と保守性を向上させることができます。特に、UIと機能の関心の分離、カスタムフックの活用、サービス層の整備、型定義の整理が重要です。

リファクタリングは段階的に行い、各段階でテストを行うことで、リスクを最小限に抑えながら、コードの品質を向上させることができます。
