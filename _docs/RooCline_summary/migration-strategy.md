# BookCardUI リファクタリング移行戦略

大規模なリファクタリングを行う場合、一度にすべての変更を行うのではなく、段階的に進めることが重要です。以下に、BookCardUIのリファクタリングを段階的に進めるための戦略を示します。

## フェーズ1: APIコールの整理

**目標**: すべてのAPIコールを`bookService.ts`に移動し、コンポーネント内では`BookService`のメソッドのみを使用するようにする。

**手順**:

1. `bookService.ts`に必要なメソッドを追加する

    - 現在`BookCard.tsx`内で直接`axios`を使用しているAPIコールをすべて特定
    - それぞれのAPIコールに対応するメソッドを`BookService`に追加

2. `BookCard.tsx`内のAPIコールを`BookService`のメソッド呼び出しに置き換える
    - 一つずつ置き換え、その都度テストを行う
    - 既存の機能が正常に動作することを確認

**メリット**:

- APIの一貫性が向上
- 将来的なAPI変更時の修正箇所が集約される
- コンポーネントの責務が明確になる

## フェーズ2: カスタムフックの導入

**目標**: 関連する状態と処理をカスタムフックに分離する。

**手順**:

1. 共通の状態管理のための`useBookCardState`フックを作成

    - ダイアログの開閉状態などを管理

2. お気に入り関連の状態と処理を`useFavoriteBook`フックに分離

    - お気に入り状態の取得と更新を管理

3. 本棚関連の状態と処理を`useBookShelf`フックに分離

    - 本棚リストの取得、本の追加・削除などを管理

4. メモ関連の状態と処理を`useBookMemo`フックに分離

    - メモの作成などを管理

5. `BookCard.tsx`内でこれらのフックを使用するように修正
    - 一つずつ置き換え、その都度テストを行う

**メリット**:

- 状態管理が整理され、コードの可読性が向上
- ロジックの再利用が容易になる
- テストが容易になる

## フェーズ3: 共通UIコンポーネントの抽出

**目標**: 共通のUI要素を独立したコンポーネントとして抽出する。

**手順**:

1. `BookCardImage`コンポーネントを作成

    - 書籍画像の表示を担当

2. `BookCardHeader`コンポーネントを作成

    - タイトルと基本情報の表示を担当

3. `BookCard.tsx`内でこれらのコンポーネントを使用するように修正
    - 既存のコードを少しずつ置き換え、その都度テストを行う

**メリット**:

- UIの一貫性が向上
- コードの重複が減少
- コンポーネントの責務が明確になる

## フェーズ4: 基本コンポーネントの作成

**目標**: 基本となる`BaseBookCard`コンポーネントを作成する。

**手順**:

1. `BaseBookCard`コンポーネントを作成

    - 基本的なカードレイアウトと共通のプロパティを持つ
    - 子コンポーネントをスロットとして受け取る設計

2. `BookCard.tsx`内で`BaseBookCard`を使用するように修正
    - 既存のコードを少しずつ置き換え、その都度テストを行う

**メリット**:

- レイアウトの一貫性が向上
- コードの重複が減少
- 将来的なUIの変更が容易になる

## フェーズ5: バリアント別コンポーネントの作成

**目標**: それぞれのバリアント（Default, Favorite, BookShelf）に特化したコンポーネントを作成する。

**手順**:

1. `DefaultBookCard`コンポーネントを作成

    - デフォルトバリアントの実装

2. `FavoriteBookCard`コンポーネントを作成

    - お気に入りバリアントの実装

3. `BookShelfBookCard`コンポーネントを作成

    - 本棚バリアントの実装

4. エントリーポイントとなる`index.tsx`を作成

    - 適切なバリアントを選択するロジックを実装

5. 既存の`BookCard.tsx`を新しい実装に置き換える
    - 全体のテストを行い、すべての機能が正常に動作することを確認

**メリット**:

- コードの可読性が大幅に向上
- 各バリアントの責務が明確になる
- 将来的な機能追加が容易になる

## テスト戦略

各フェーズの実装後、以下のテストを行うことが重要です：

1. **機能テスト**

    - すべての機能（詳細表示、お気に入り登録、本棚への追加など）が正常に動作することを確認
    - エラーケースの処理が適切に行われることを確認

2. **UI表示テスト**

    - 各バリアントの表示が正しいことを確認
    - レスポンシブデザインが正しく機能することを確認

3. **パフォーマンステスト**
    - リファクタリング前後でのパフォーマンスの変化を確認
    - 不要な再レンダリングが発生していないことを確認

## リスク管理

1. **機能の欠落**

    - リファクタリング前に現在の機能を詳細に文書化
    - 各フェーズ後に機能チェックリストを使用して確認

2. **パフォーマンスの低下**

    - コンポーネントの分割によるパフォーマンスへの影響を監視
    - 必要に応じてメモ化（React.memo, useMemo, useCallback）を導入

3. **移行中の不整合**
    - 一時的に両方の実装を維持し、フィーチャーフラグで切り替え可能にする
    - 段階的に新しい実装に移行

## タイムライン

| フェーズ                            | 推定期間 | 主な成果物                                     |
| ----------------------------------- | -------- | ---------------------------------------------- |
| 1. APIコールの整理                  | 1日      | 拡張された`bookService.ts`                     |
| 2. カスタムフックの導入             | 2日      | 各種カスタムフック                             |
| 3. 共通UIコンポーネントの抽出       | 1日      | 共通UIコンポーネント                           |
| 4. 基本コンポーネントの作成         | 1日      | `BaseBookCard`コンポーネント                   |
| 5. バリアント別コンポーネントの作成 | 2日      | バリアント別コンポーネントとエントリーポイント |
| テストと調整                        | 1日      | 最終的な実装                                   |

**合計**: 約1週間

## 結論

この移行戦略に従うことで、リスクを最小限に抑えながら、BookCardUIのリファクタリングを段階的に進めることができます。各フェーズの完了後にテストを行い、問題があれば早期に発見して修正することが重要です。

最終的には、APIコールとUIが明確に分離され、各バリアントの実装が整理された、メンテナンス性の高いコードベースが実現します。
