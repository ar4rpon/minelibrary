# MineLibrary フロントエンドリファクタリング概要

## はじめに

MineLibraryプロジェクトのフロントエンド部分、特に`/resources/ts`配下のコードについて、保守性と拡張性を向上させるためのリファクタリング計画をまとめました。このドキュメントでは、リファクタリングの目的、計画、実装例、移行戦略、およびコーディングガイドラインについて概説します。

## 現状の課題

現在のコードベースには以下の課題があります：

1. **関心の分離が不十分**

    - UIコンポーネントにビジネスロジックが混在している
    - ダイアログの状態管理とAPIリクエストが密結合している

2. **ディレクトリ構造の問題**

    - 機能とUIの分離が不明確
    - 関連するコンポーネントが散在している（DialogとComponentsの分離など）

3. **再利用性の低さ**
    - コンポーネント間の依存関係が強い
    - 共通の処理が複数の場所に重複している

## リファクタリングの目的

1. **関心の分離を明確にする**

    - UIコンポーネントと機能コンポーネントを分離
    - ビジネスロジックをカスタムフックに抽出

2. **ディレクトリ構造を整理する**

    - 機能ごとのディレクトリ分け
    - 関連するコンポーネントをグループ化

3. **再利用性を向上させる**

    - 小さなコンポーネントに分割
    - 共通の処理をカスタムフックに抽出

4. **保守性を向上させる**
    - 一貫した命名規則
    - 適切なドキュメント化
    - 型定義の整理

## リファクタリング計画の概要

リファクタリング計画は以下の4つのドキュメントに詳細にまとめられています：

1. [**リファクタリング計画**](./_docs/RooCline_summary/refactoring-plan.md) - 全体的なリファクタリングの方針と手順
2. [**コーディングガイド**](./_docs/RooCline_summary/coding-guide.md) - 新しいコードを書く際のガイドライン
3. [**実装例**](./_docs/RooCline_summary/implementation-examples.md) - 新しいアーキテクチャに基づいた実装例
4. [**移行戦略**](./_docs/RooCline_summary/migration-strategy.md) - 現在のコードから新しいアーキテクチャへの移行手順

## 新しいディレクトリ構造

```
resources/ts/
├── components/                  # 純粋なUIコンポーネント
│   ├── ui/                      # 基本UIコンポーネント
│   ├── book/                    # 書籍関連のUIコンポーネント
│   └── bookshelf/               # 本棚関連のUIコンポーネント
│       ├── card/                # カード関連のコンポーネント
│       ├── elements/            # カードの構成要素
│       └── index.tsx            # エントリーポイント
├── features/                    # 機能単位のコンテナコンポーネント
│   ├── book/                    # 書籍機能
│   └── bookshelf/               # 本棚機能
│       ├── components/          # 本棚機能固有のコンポーネント
│       ├── hooks/               # 本棚機能のカスタムフック
│       └── pages/               # 本棚機能のページコンポーネント
├── services/                    # APIサービス
├── hooks/                       # 共通カスタムフック
└── types/                       # 型定義
```

## 主要な改善点

### 1. 関心の分離

**UIコンポーネント（Presentational Components）**

- 見た目のみに責任を持つ
- propsを通じてデータと振る舞いを受け取る
- 状態管理やAPIリクエストを行わない

**機能コンポーネント（Container Components）**

- 状態管理とロジックに責任を持つ
- UIコンポーネントにデータと振る舞いを提供する
- APIリクエストやイベントハンドリングを行う

### 2. カスタムフックの活用

状態管理やAPIリクエストなどのロジックをカスタムフックに抽出することで、コンポーネントの責務を軽減し、ロジックの再利用性を向上させます。

```tsx
// 例: ダイアログ状態管理のカスタムフック
export function useBookShelfDialogs(
    bookShelfId: number,
    includeAddBook = false,
) {
    const [isEditOpen, setIsEditOpen] = useState(false);
    const [isDeleteOpen, setIsDeleteOpen] = useState(false);
    // ...

    return {
        dialogs: {
            edit: {
                isOpen: isEditOpen,
                open: () => setIsEditOpen(true),
                close: () => setIsEditOpen(false),
                // ...
            },
            // ...
        },
    };
}
```

### 3. サービス層の整備

APIリクエストをサービス層に抽出することで、エラーハンドリングを統一し、コンポーネントからビジネスロジックを分離します。

```tsx
// 例: BookShelfサービス
export const bookShelfService = {
    update: async (
        bookShelfId: number,
        data: UpdateBookShelfData,
    ): Promise<Result<BookShelf>> => {
        try {
            // ...
        } catch (error) {
            // ...
        }
    },
    // ...
};
```

### 4. 型定義の整理

型定義を整理し、インターフェースを分割することで、型の再利用性を向上させます。

```tsx
// 例: 分割された型定義
export interface BookShelfBase {
    bookShelfId: number;
    name: string;
    description: string;
    isPublic: boolean;
}

export interface BookShelfCardProps extends BookShelfBase {
    image?: string;
    onEdit: () => void;
    onDelete: () => void;
}
```

## 移行戦略

移行は段階的に行い、リスクを最小限に抑えながら、コードの品質と保守性を向上させます。

1. **準備と計画** (1週間)
2. **基盤の整備** (1週間)
3. **UIコンポーネントの移行** (2週間)
4. **機能コンポーネントの移行** (2週間)
5. **ページコンポーネントの移行** (1週間)
6. **切り替えと検証** (1週間)
7. **クリーンアップと最適化** (1週間)

**合計期間**: 約2ヶ月

## コーディングガイド

新しいコードを書く際は、以下の原則に従ってください：

1. **単一責任の原則** - 各コンポーネントは1つの責任のみを持つ
2. **コンポジションの活用** - 小さなコンポーネントを組み合わせて大きなコンポーネントを作る
3. **型の再利用** - 共通の型は再利用し、必要に応じて型を拡張する
4. **状態の局所化** - 状態は必要な最小限のスコープに保持する
5. **サービス層の活用** - APIリクエストはサービス層に抽出する

詳細なコーディングガイドは[こちら](./_docs/RooCline_summary/coding-guide.md)を参照してください。

## 結論

このリファクタリング計画を実行することで、以下の改善が期待できます：

1. **コードの保守性向上** - 関心の分離と明確な責務により、コードの理解と保守が容易になる
2. **拡張性の向上** - 新機能の追加が容易になる
3. **再利用性の向上** - 小さなコンポーネントとフックが再利用可能になる
4. **品質の向上** - 一貫した構造と命名規則により、コードの品質が向上する

リファクタリングは段階的に行い、各段階でテストを行うことで、リスクを最小限に抑えながら、コードの品質と保守性を向上させることができます。
